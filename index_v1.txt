<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>voxelo</title>
	<!-- https://unpkg.com/alpinejs https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js -->
	<script src="./three.js"></script>
	<script src="./OrbitControls.js"></script>
	<!--<script src="./fengari-interop.js"></script>-->
	<script src="./fengari-web.js"></script>
	<script src="./alpine.js" defer></script>
</head>
<body>
	<script>
	// inspired by Replicube
	
	// --- CONFIG ---
	const GRID_SIZE = 9
	const GRID_SIZE_HALF = GRID_SIZE/2
	// --------------
	
	function* range(start, end, step = 1) {
		if (end === undefined) {
			end = start;
			start = 0;
		}

		for (let i = start; i < end; i += step) {
			yield i;
		}
	}
	
	const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
	
	document.addEventListener('alpine:init', () => {
        Alpine.data('appData', () => ({
			luaCode: '',
			showError: false,
			voxelTask: null,
			init() {
				// "imports"
				const { lua, lauxlib, lualib, to_luastring, interop } = fengari
				const THREE = window.THREE
				
				// create the scene
				const canvas = document.querySelector('#threeCanvas')
				
				const scene = new THREE.Scene()
				const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000)
				camera.position.set(-GRID_SIZE_HALF+2, GRID_SIZE_HALF, -GRID_SIZE-4)
				
				const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
				renderer.setSize(canvas.clientWidth, canvas.clientHeight)
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
				const controls = new THREE.OrbitControls(camera, renderer.domElement)
				controls.rotateSpeed = 0.5
				controls.enablePan = false

				const AXES_HELPER_OFFSET = 0.1
				const axesHelper = new THREE.AxesHelper(GRID_SIZE + AXES_HELPER_OFFSET * 2)
				axesHelper.position.set(-GRID_SIZE_HALF - AXES_HELPER_OFFSET, -GRID_SIZE_HALF - AXES_HELPER_OFFSET, -GRID_SIZE_HALF - AXES_HELPER_OFFSET)
				axesHelper.name = 'AxesHelper'
				scene.add(axesHelper)
				
				const resizeObserver = new ResizeObserver(() => {
					const width = canvas.clientWidth
					const height = canvas.clientHeight

					camera.aspect = width / height
					camera.updateProjectionMatrix()
					
					renderer.setSize(width, height)
				})
				resizeObserver.observe(canvas)
				
				// create lua state
				this.L = lauxlib.luaL_newstate()
				lualib.luaL_openlibs(this.L)
				lauxlib.luaL_requiref(this.L, to_luastring("js"), interop.luaopen_js, 1)
				lua.lua_pop(this.L, 1)
				const setupCode = `
					sin, cos, abs, floor, ceil, pi, sqrt, random, min, max = 
					math.sin, math.cos, math.abs, math.floor, math.ceil, math.pi, math.sqrt, math.random, math.min, math.max
					EMPTY, WHITE, GRAY, BLACK, SALMON, PINK, PURPLE, RED, ORANGE, YELLOW, LIME, GREEN, INDIGO, BLUE, CYAN, BROWN, MAROON = 
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
				`;
				lauxlib.luaL_dostring(this.L, to_luastring(setupCode));
			
				// make the game logic
				// grid xyz are [-3,3] (ints, includes 0), c is [1,16] (int, specifies the color)
				// colors are taken directly from replicube
				const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)
				const cubeColors = [
					0xdfe9f5, 0x687595, 0x101518, 0xf8aaa8, 0xd4689a, 0x782d96, 
					0xe93562, 0xf2825c, 0xffc86e, 0x88c34d, 0x3f9e5a, 0x373461, 
					0x4854a8, 0x7198d9, 0x9e5252, 0x4e2537
				].map(c => new THREE.MeshBasicMaterial({ color: c }));
				const edgesGeometry = new THREE.EdgesGeometry(cubeGeometry)
				const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }) // Black border
				function renderCube(x, y, z, c=0) {
					if (c <= 0) return
					const cube = new THREE.Mesh(cubeGeometry, cubeColors[clamp(c, 1, 16) - 1])
					cube.position.set(x, y, z)
					const border = new THREE.LineSegments(edgesGeometry, edgesMaterial)
					cube.add(border)
					scene.add(cube)
				}
				function clearScene() {
					for (let i = scene.children.length - 1; i >= 0; i--) {
						const child = scene.children[i];
						if (child.name !== 'AxesHelper' && (child instanceof THREE.Mesh || child instanceof THREE.LineSegments)) {
							scene.remove(child);
							// we dont need to dispose geometry and materials, since we reuse them
						}
					}
				}
				function renderScene(_voxelTask) {
					clearScene()
					console.log('renderScene', this.voxelTask)
					const coordRange = [-Math.floor(GRID_SIZE_HALF), Math.floor(GRID_SIZE_HALF)+1]
					for (const x of range(...coordRange)){
						for (const y of range(...coordRange)){
							for (const z of range(...coordRange)){
								lua.lua_pushnumber(this.L, x); lua.lua_setglobal(this.L, to_luastring("x"))
								lua.lua_pushnumber(this.L, y); lua.lua_setglobal(this.L, to_luastring("y"))
								lua.lua_pushnumber(this.L, z); lua.lua_setglobal(this.L, to_luastring("z"))
								try {
									const result = _voxelTask()
									if (result && result > 0) this.renderCube(x, y, z, result)
								} catch (e) { this.showError = true }
								/*const colorResult = _voxelTask(x, y, z);
								if (colorResult > 0) {
									renderCube(x, y, z, colorResult);
								}*/
							}
						}
					}
				}
				
				this.$watch('luaCode', (v) => {
					this.compileCode(v)
					renderScene(this.voxelTask)
				})
				
				//renderCube(0,0,0)
				//renderCube(1,1,1)
				//renderCube(-3,-3,-3)
				
				// start
				const animate = () => {
					requestAnimationFrame(animate)
					controls.update()
					renderer.render(scene, camera)
				}
				animate()
			},
			compileCode(_luaCode) {
				const { lua, lauxlib, lualib, to_luastring, interop } = fengari
				try {
					const input = (_luaCode ?? '').trim();
					if (!input) {
						this.voxelTask = null;
						return;
					}
					//const code = input.startsWith('return') ? input : `return ${input}`;
					const wrappedCode = `
						sin = math.sin
						cos = math.cos
						abs = math.abs
						floor = math.floor
						ceil = math.ceil
						pi = math.pi
						sqrt = math.sqrt
						random = math.random
						min = math.min
						max = math.max
						EMPTY = 0
						WHITE = 1
						GRAY = 2
						BLACK = 3
						SALMON = 4
						PINK = 5
						PURPLE = 6
						RED = 7
						ORANGE = 8
						YELLOW = 9
						LIME = 10
						GREEN = 11
						INDIGO = 12
						BLUE = 13
						CYAN = 14
						BROWN = 15
						MAROON = 16
						return function(x, y, z)
							${input}
						end`
					
					const status = lauxlib.luaL_dostring(this.L, to_luastring(wrappedCode))
					if (status !== lua.LUA_OK) {
						throw new Error(lua.lua_tojsstring(this.L, -1))
					}
					this.voxelTask = interop.tojs(this.L, -1)
					console.log('compileCode', this.voxelTask)
					lua.lua_pop(this.L, 1)
					this.showError = false
				} catch (err) {
					this.showError = true
					console.error("Lua Compilation Error:", err);
					//alert("Check your Lua syntax: " + err);
				}
			}
        }))
    })
	</script>
	<style>
	[x-cloak] { display: none !important; }
	</style>
	<div x-data="appData()">
		<div style="position: relative; display: inline-block;">
			<textarea 
				x-model.debounce.500ms="luaCode" 
				style="font-size: 1.125rem; line-height: 1.5; display: block;" 
				rows="5" 
				cols="40">
			</textarea>
			<div
				x-show="showError" 
				x-transition
				x-cloak
				style="position: absolute; left: 10px; bottom: 10px; pointer-events: none; color: white; background-color: red; font-weight: bold; width: 20px; height: 20px; text-align: center; border-radius: 0.25rem;"
			>
				!
			</div>
		</div>
		<canvas id="threeCanvas" style="width: 600px; height: 600px; display: block;"></canvas>
	</div>
</body>
</html>
