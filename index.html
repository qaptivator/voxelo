<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>voxelo</title>
	<!-- https://unpkg.com/alpinejs https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js -->
	<script src="./three.js"></script>
	<script src="./OrbitControls.js"></script>
	<script src="./fengari-web.js"></script>
	<script src="./alpine.js" defer></script>
</head>
<body>
	<script>
	// inspired by Replicube
	// https://github.com/qaptivator/voxelo
	
	// --- CONFIG ---
	const GRID_SIZE = 9
	const GRID_SIZE_HALF = GRID_SIZE/2
	const STARTING_CODE = `-- web replicube recreation, voxelo
c = y + 10
if abs(x)<2 and abs(y)<2 then
    c = 0
end
if abs(z)<2 and abs(y)<2 then
    c = 0
end
if abs(x)<2 and abs(z)<2 then
    c = 0
end
return c`
	// --------------
	
	function* range(start, end, step = 1) {
		if (end === undefined) {
			end = start;
			start = 0;
		}

		for (let i = start; i < end; i += step) {
			yield i;
		}
	}
	
	const clamp = (num, min, max) => Math.min(Math.max(num, min), max)
	
	document.addEventListener('alpine:init', () => {
		Alpine.data('appData', () => ({
			luaCode: STARTING_CODE ?? '',
			showError: false,
			voxelTask: null,
			L: null,

			init() {
				// "imports"
				const { lua, lauxlib, lualib, to_luastring, interop } = fengari
				const THREE = window.THREE
				
				// create the scene
				const canvas = document.querySelector('#threeCanvas')
				
				const scene = new THREE.Scene()
				const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000)
				camera.position.set(-GRID_SIZE_HALF+2, GRID_SIZE_HALF, -GRID_SIZE-4)
				
				const renderer = new THREE.WebGLRenderer({ canvas, antialias: true })
				renderer.setSize(canvas.clientWidth, canvas.clientHeight)
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
				const controls = new THREE.OrbitControls(camera, renderer.domElement)
				controls.rotateSpeed = 0.5
				controls.enablePan = false

				const AXES_HELPER_OFFSET = 0.1
				const axesHelper = new THREE.AxesHelper(GRID_SIZE + AXES_HELPER_OFFSET * 2)
				axesHelper.position.set(-GRID_SIZE_HALF - AXES_HELPER_OFFSET, -GRID_SIZE_HALF - AXES_HELPER_OFFSET, -GRID_SIZE_HALF - AXES_HELPER_OFFSET)
				axesHelper.name = 'AxesHelper'
				scene.add(axesHelper)
				
				const resizeObserver = new ResizeObserver(() => {
					const width = canvas.clientWidth
					const height = canvas.clientHeight
					camera.aspect = width / height
					camera.updateProjectionMatrix()
					renderer.setSize(width, height)
				})
				resizeObserver.observe(canvas)
				
				// make the game logic
				this.L = lauxlib.luaL_newstate()
				lualib.luaL_openlibs(this.L)
				lauxlib.luaL_requiref(this.L, to_luastring("js"), interop.luaopen_js, 1)
				lua.lua_pop(this.L, 1)

				// Pack math and colors into global scope
				const setupCode = `
					sin, cos, abs, floor, ceil, pi, sqrt, random, min, max = 
					math.sin, math.cos, math.abs, math.floor, math.ceil, math.pi, math.sqrt, math.random, math.min, math.max
					EMPTY, WHITE, GRAY, BLACK, SALMON, PINK, PURPLE, RED, ORANGE, YELLOW, LIME, GREEN, INDIGO, BLUE, CYAN, BROWN, MAROON = 
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
				`
				lauxlib.luaL_dostring(this.L, to_luastring(setupCode))

				// grid xyz are [-3,3] (ints, includes 0), c is [1,16] (int, specifies the color)
				// colors are taken directly from replicube (not the names above though, they are made up)
				const cubeGeometry = new THREE.BoxGeometry(1, 1, 1)
				const cubeColors = [
					0xdfe9f5, 0x687595, 0x101518, 0xf8aaa8, 0xd4689a, 0x782d96, 
					0xe93562, 0xf2825c, 0xffc86e, 0x88c34d, 0x3f9e5a, 0x373461, 
					0x4854a8, 0x7198d9, 0x9e5252, 0x4e2537
				].map(c => new THREE.MeshBasicMaterial({ color: c }))
				const edgesGeometry = new THREE.EdgesGeometry(cubeGeometry)
				const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }) 

				const renderCube = (x, y, z, c=0) => {
					if (c <= 0) return
					const cube = new THREE.Mesh(cubeGeometry, cubeColors[clamp(Math.floor(c), 1, 16)-1])
					cube.position.set(x, y, z)
					const border = new THREE.LineSegments(edgesGeometry, edgesMaterial)
					cube.add(border)
					scene.add(cube)
				}

				const clearScene = () => {
					for (let i = scene.children.length - 1; i >= 0; i--) {
						const child = scene.children[i]
						if (child.name !== 'AxesHelper' && (child instanceof THREE.Mesh || child instanceof THREE.LineSegments)) {
							scene.remove(child)
						}
					}
				}

				this.renderScene = () => {
					clearScene()
					if (!this.voxelTask) return
					
					const coordRange = [-Math.floor(GRID_SIZE_HALF), Math.floor(GRID_SIZE_HALF)+1]
					for (const x of range(...coordRange)){
						for (const y of range(...coordRange)){
							for (const z of range(...coordRange)){
								lua.lua_pushnumber(this.L, x)
								lua.lua_setglobal(this.L, to_luastring("x"))
								lua.lua_pushnumber(this.L, y)
								lua.lua_setglobal(this.L, to_luastring("y"))
								lua.lua_pushnumber(this.L, z)
								lua.lua_setglobal(this.L, to_luastring("z"))

								try {
									const colorResult = this.voxelTask()
									if (colorResult > 0) {
										renderCube(x, y, z, colorResult)
									}
								} catch (e) {
									this.showError = true
								}
							}
						}
					}
				}
				
				if (this.luaCode) {
					this.compileCode(this.luaCode)
					this.renderScene()
				}
				this.$watch('luaCode', (v) => {
					this.compileCode(v)
					this.renderScene()
				})
				
				// start
				const animate = () => {
					requestAnimationFrame(animate)
					controls.update()
					renderer.render(scene, camera)
				}
				animate()
			},

			compileCode(_luaCode) {
				const { lua, lauxlib, to_luastring, interop } = fengari
				try {
					const input = (_luaCode ?? '').trim()
					if (!input) {
						this.voxelTask = null
						return
					}
					const wrappedCode = `return function() ${input} end`
					const status = lauxlib.luaL_dostring(this.L, to_luastring(wrappedCode))
					if (status !== lua.LUA_OK) {
						throw new Error(lua.lua_tojsstring(this.L, -1))
					}
					this.voxelTask = interop.tojs(this.L, -1)
					lua.lua_pop(this.L, 1)
					this.showError = false
				} catch (err) {
					this.showError = true
					console.error("Lua Compilation Error:", err)
				}
			}
		}))
	})
	</script>
	<style>
	[x-cloak] { display: none !important; }
	:root {
	  --canvas-width: 600px;
	}
	body {
	  background-color: #1a1a1a;
	}
	</style>
	<div x-data="appData()" style="display: flex; flex-direction: column;">
		<div style="position: relative; display: inline-block; width: calc(var(--canvas-width) - 35px); margin: 0;">
			<textarea 
				x-model.debounce.500ms="luaCode" 
				style="font-size: 1.125rem; line-height: 1.5; display: block; width: 100%; background-color: #1e1e1e; color: white; border: 2px solid black; padding: 0.5rem 1rem 0.5rem 1rem; margin: 0;" 
				rows="6" 
				cols="40">
			</textarea>
			<div
				x-show="showError" 
				x-transition
				x-cloak
				style="position: absolute; left: 10px; bottom: 10px; pointer-events: none; color: white; background-color: red; font-weight: bold; width: 20px; height: 20px; text-align: center; border-radius: 0.25rem;"
			>
				!
			</div>
		</div>
		<canvas id="threeCanvas" style="width: var(--canvas-width); height: var(--canvas-width); display: block; margin: 0;"></canvas>
	</div>
</body>
</html>
